{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar getScrollTop = exports.getScrollTop = function getScrollTop() {\n  return document.body.scrollTop || document.documentElement.scrollTop;\n}; // get vertical offsets of element, taking scrollTop into consideration\n\n\nvar getElementOffset = exports.getElementOffset = function getElementOffset(element) {\n  var scrollTop = getScrollTop();\n\n  var _element$getBoundingC = element.getBoundingClientRect(),\n      top = _element$getBoundingC.top,\n      bottom = _element$getBoundingC.bottom;\n\n  return {\n    top: Math.floor(top + scrollTop),\n    bottom: Math.floor(bottom + scrollTop)\n  };\n}; // does scrollTop live within element bounds?\n\n\nvar doesElementContainScrollTop = exports.doesElementContainScrollTop = function doesElementContainScrollTop(element) {\n  var extraOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var scrollTop = getScrollTop();\n  var offsetTop = getElementOffset(element).top + extraOffset;\n  return scrollTop >= offsetTop && scrollTop < offsetTop + element.offsetHeight;\n}; // is el2's location more relevant than el2,\n// parent-child relationship aside?\n\n\nvar checkLocationRelevance = exports.checkLocationRelevance = function checkLocationRelevance(el1, el2) {\n  var _getElementOffset = getElementOffset(el1),\n      top1 = _getElementOffset.top,\n      bottom1 = _getElementOffset.bottom;\n\n  var _getElementOffset2 = getElementOffset(el2),\n      top2 = _getElementOffset2.top,\n      bottom2 = _getElementOffset2.bottom;\n\n  if (top1 === top2) {\n    if (bottom1 === bottom2) {\n      // top and bottom of compared elements are the same,\n      // so return one randomly in a deterministic way\n      return el1 < el2;\n    } // top of compared elements is the same, so return whichever\n    // element has its bottom higher on the page\n\n\n    return bottom2 < bottom1;\n  } // top of compared elements differ, so return true\n  // if tested element has its top lower on the page\n\n\n  return top2 > top1;\n}; // check if el2 is more relevant than el1, considering child-parent\n// relationships as well as node location.\n\n\nvar checkElementRelevance = exports.checkElementRelevance = function checkElementRelevance(el1, el2) {\n  if (el1.contains(el2)) {\n    // el2 is child, so it gains relevance priority\n    return true;\n  } else if (!el2.contains(el1) && checkLocationRelevance(el1, el2)) {\n    // el1 and el2 are unrelated, but el2 has a better location,\n    // so it gains relevance priority\n    return true;\n  }\n\n  return false;\n}; // given a set of anchors, find which one is, given the following logic:\n// 1. children nodes are more relevant than parent nodes\n// 2. if neither node contains the other, and their top locations differ,\n//    the node with the top lower on the page is more relevant\n// 3. if neither node contains the other, and their top locations are the same,\n//    the node with the bottom higher on the page is more relevant\n// 4. if neither node contains the other, and their top and bottom locations\n//    are the same, a node is chosen at random, in a deterministic way,\n//    to be more relevant.\n\n\nvar getBestAnchorGivenScrollLocation = exports.getBestAnchorGivenScrollLocation = function getBestAnchorGivenScrollLocation(anchors, offset) {\n  var bestId = void 0,\n      bestElement = void 0;\n  Object.keys(anchors).forEach(function (id) {\n    var element = anchors[id];\n\n    if (doesElementContainScrollTop(element, offset)) {\n      if (!bestElement || checkElementRelevance(bestElement, element)) {\n        bestElement = element;\n        bestId = id;\n      }\n    }\n  });\n  return bestId;\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","getScrollTop","document","body","scrollTop","documentElement","getElementOffset","element","_element$getBoundingC","getBoundingClientRect","top","bottom","Math","floor","doesElementContainScrollTop","extraOffset","arguments","length","undefined","offsetTop","offsetHeight","checkLocationRelevance","el1","el2","_getElementOffset","top1","bottom1","_getElementOffset2","top2","bottom2","checkElementRelevance","contains","getBestAnchorGivenScrollLocation","anchors","offset","bestId","bestElement","keys","forEach","id"],"sources":["/Users/galinamorozova/Documents/GitHub/transparent/node_modules/react-scrollable-anchor/lib/utils/scroll.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar getScrollTop = exports.getScrollTop = function getScrollTop() {\n  return document.body.scrollTop || document.documentElement.scrollTop;\n};\n\n// get vertical offsets of element, taking scrollTop into consideration\nvar getElementOffset = exports.getElementOffset = function getElementOffset(element) {\n  var scrollTop = getScrollTop();\n\n  var _element$getBoundingC = element.getBoundingClientRect(),\n      top = _element$getBoundingC.top,\n      bottom = _element$getBoundingC.bottom;\n\n  return {\n    top: Math.floor(top + scrollTop),\n    bottom: Math.floor(bottom + scrollTop)\n  };\n};\n\n// does scrollTop live within element bounds?\nvar doesElementContainScrollTop = exports.doesElementContainScrollTop = function doesElementContainScrollTop(element) {\n  var extraOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var scrollTop = getScrollTop();\n  var offsetTop = getElementOffset(element).top + extraOffset;\n  return scrollTop >= offsetTop && scrollTop < offsetTop + element.offsetHeight;\n};\n\n// is el2's location more relevant than el2,\n// parent-child relationship aside?\nvar checkLocationRelevance = exports.checkLocationRelevance = function checkLocationRelevance(el1, el2) {\n  var _getElementOffset = getElementOffset(el1),\n      top1 = _getElementOffset.top,\n      bottom1 = _getElementOffset.bottom;\n\n  var _getElementOffset2 = getElementOffset(el2),\n      top2 = _getElementOffset2.top,\n      bottom2 = _getElementOffset2.bottom;\n\n  if (top1 === top2) {\n    if (bottom1 === bottom2) {\n      // top and bottom of compared elements are the same,\n      // so return one randomly in a deterministic way\n      return el1 < el2;\n    }\n    // top of compared elements is the same, so return whichever\n    // element has its bottom higher on the page\n    return bottom2 < bottom1;\n  }\n  // top of compared elements differ, so return true\n  // if tested element has its top lower on the page\n  return top2 > top1;\n};\n\n// check if el2 is more relevant than el1, considering child-parent\n// relationships as well as node location.\nvar checkElementRelevance = exports.checkElementRelevance = function checkElementRelevance(el1, el2) {\n  if (el1.contains(el2)) {\n    // el2 is child, so it gains relevance priority\n    return true;\n  } else if (!el2.contains(el1) && checkLocationRelevance(el1, el2)) {\n    // el1 and el2 are unrelated, but el2 has a better location,\n    // so it gains relevance priority\n    return true;\n  }\n  return false;\n};\n\n// given a set of anchors, find which one is, given the following logic:\n// 1. children nodes are more relevant than parent nodes\n// 2. if neither node contains the other, and their top locations differ,\n//    the node with the top lower on the page is more relevant\n// 3. if neither node contains the other, and their top locations are the same,\n//    the node with the bottom higher on the page is more relevant\n// 4. if neither node contains the other, and their top and bottom locations\n//    are the same, a node is chosen at random, in a deterministic way,\n//    to be more relevant.\nvar getBestAnchorGivenScrollLocation = exports.getBestAnchorGivenScrollLocation = function getBestAnchorGivenScrollLocation(anchors, offset) {\n  var bestId = void 0,\n      bestElement = void 0;\n\n  Object.keys(anchors).forEach(function (id) {\n    var element = anchors[id];\n    if (doesElementContainScrollTop(element, offset)) {\n      if (!bestElement || checkElementRelevance(bestElement, element)) {\n        bestElement = element;\n        bestId = id;\n      }\n    }\n  });\n  return bestId;\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}